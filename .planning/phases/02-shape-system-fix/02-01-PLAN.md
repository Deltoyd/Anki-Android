---
phase: 02-shape-system-fix
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PaintingPuzzleView.kt
  - AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PuzzlePiecePathGenerator.kt
autonomous: false

must_haves:
  truths:
    - "Unlocked pieces clip the painting to the exact same jigsaw outline as their locked PNG counterpart"
    - "No visible shape mismatch between locked gray puzzle sections and unlocked painting sections"
    - "Tab and hole boundaries align at piece intersections (tabs fill neighboring holes seamlessly)"
    - "All 14 piece variants render correctly for unlocked pieces (4 corners, 8 borders, 2 interiors)"
  artifacts:
    - path: "AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PaintingPuzzleView.kt"
      provides: "PNG alpha mask clipping for unlocked pieces"
      contains: "extractAlpha\\|DST_IN\\|alphaMask"
  key_links:
    - from: "PaintingPuzzleView.drawPuzzlePiece (unlocked branch)"
      to: "pieceBitmaps[pieceType]"
      via: "PNG alpha used as clip mask for painting"
      pattern: "pieceBitmaps.*pieceType.*extractAlpha\\|DST_IN\\|alphaMask"
    - from: "PaintingPuzzleView.drawPeekMode"
      to: "pieceBitmaps[pieceType]"
      via: "PNG alpha used for peek mode outlines (replacing pathGenerator)"
      pattern: "pieceBitmaps.*pieceType"
---

<objective>
Replace PuzzlePiecePathGenerator clip paths with PNG alpha mask clipping so unlocked pieces use the exact same jigsaw shape as their locked PNG counterparts.

Purpose: Fix the visible shape mismatch between locked and unlocked puzzle pieces that the user reported. Currently unlocked pieces use bezier-curve paths from PuzzlePiecePathGenerator which produce a different jigsaw shape than the 14 PNG assets used for locked pieces. After this plan, both locked and unlocked pieces share the same shape source (the PNG assets).

Output: Modified PaintingPuzzleView.kt with alpha mask clipping; PuzzlePiecePathGenerator.kt removed or deprecated.
</objective>

<execution_context>
@/Users/rolandharper/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rolandharper/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-puzzle-assembly-fix/01-02-SUMMARY.md
@AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PaintingPuzzleView.kt
@AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PuzzlePiecePathGenerator.kt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace path-based clipping with PNG alpha mask clipping for unlocked pieces</name>
  <files>
    AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PaintingPuzzleView.kt
    AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PuzzlePiecePathGenerator.kt
  </files>
  <action>
Replace the unlocked piece rendering in `PaintingPuzzleView.drawPuzzlePiece()` to use PNG alpha masks instead of `PuzzlePiecePathGenerator` paths. The technique:

**Core approach — PorterDuff DST_IN compositing:**

For each unlocked piece, use the corresponding piece PNG's alpha channel as a clip mask for the painting. This guarantees the unlocked piece shape is pixel-identical to the locked piece shape.

**Implementation steps:**

1. **Add imports** for `PorterDuff`, `PorterDuffXfermode`, `Rect`, and `RectF` (if not already imported).

2. **Add a reusable Paint for alpha masking:**
   ```kotlin
   private val alphaMaskPaint = Paint(Paint.ANTI_ALIAS_FLAG or Paint.FILTER_BITMAP_FLAG).apply {
       xfermode = PorterDuffXfermode(PorterDuff.Mode.DST_IN)
   }
   ```

3. **Rewrite the unlocked branch in `drawPuzzlePiece()`:**
   Replace the current unlocked block (lines ~399-424) which calls `pathGenerator.getPiecePath()` and `canvas.clipPath()`.

   New approach:
   ```kotlin
   if (index in unlockedPieces) {
       val pieceType = getPieceType(row, col)
       val maskBmp = pieceBitmaps[pieceType] ?: return

       // Compute the same destination rect as drawLockedPiecePng
       val bmpWidth = maskBmp.width.toFloat()
       val bmpHeight = maskBmp.height.toFloat()
       val scaleX = pieceWidth / PNG_BODY_SIZE
       val scaleY = pieceHeight / PNG_BODY_SIZE
       val (bodyX, bodyY) = PIECE_BODY_OFFSETS[pieceType] ?: Pair(0f, 0f)
       val destLeft = left - bodyX * scaleX
       val destTop = top - bodyY * scaleY
       val destRight = destLeft + bmpWidth * scaleX
       val destBottom = destTop + bmpHeight * scaleY

       // Use saveLayer to create an offscreen buffer for compositing
       val layerRect = RectF(destLeft, destTop, destRight, destBottom)
       canvas.saveLayer(layerRect, null)

       // Draw painting (DST) — only the area under the piece
       val paint = if (index in animatingPieces) {
           Paint().apply { alpha = animatingPieces[index] ?: 255 }
       } else {
           null
       }
       scaledBitmap?.let {
           canvas.drawBitmap(it, puzzleRect.left, puzzleRect.top, paint)
       }

       // Apply PNG alpha mask (SRC) — DST_IN keeps only painting pixels where mask is opaque
       tmpPieceRect.set(destLeft, destTop, destRight, destBottom)
       canvas.drawBitmap(maskBmp, null, tmpPieceRect, alphaMaskPaint)

       canvas.restore()

       // Draw border using the same mask approach or skip for now
       // (locked pieces already provide visual borders via their PNG outlines)
   }
   ```

   Key points:
   - `saveLayer()` creates an offscreen compositing buffer (required for PorterDuff to work correctly — it composites within the layer, not against the full canvas)
   - The painting is drawn first as DST
   - The piece PNG is drawn second with `PorterDuff.Mode.DST_IN`, which keeps painting pixels only where the PNG has alpha > 0
   - The dest rect calculation is identical to `drawLockedPiecePng()` to ensure pixel-perfect alignment
   - Animation alpha still works (applied to the painting draw)

4. **Extract shared dest rect calculation:**
   Since both `drawLockedPiecePng()` and the new unlocked rendering use the same dest rect math, extract a helper:
   ```kotlin
   private fun getPieceDestRect(row: Int, col: Int, left: Float, top: Float): RectF? {
       val pieceType = getPieceType(row, col)
       val bmp = pieceBitmaps[pieceType] ?: return null
       val bmpWidth = bmp.width.toFloat()
       val bmpHeight = bmp.height.toFloat()
       val scaleX = pieceWidth / PNG_BODY_SIZE
       val scaleY = pieceHeight / PNG_BODY_SIZE
       val (bodyX, bodyY) = PIECE_BODY_OFFSETS[pieceType] ?: Pair(0f, 0f)
       val destLeft = left - bodyX * scaleX
       val destTop = top - bodyY * scaleY
       val destRight = destLeft + bmpWidth * scaleX
       val destBottom = destTop + bmpHeight * scaleY
       return RectF(destLeft, destTop, destRight, destBottom)
   }
   ```
   Then refactor `drawLockedPiecePng()` to use it too.

5. **Update peek mode (`drawPeekMode()`):**
   The peek mode at line ~377 also uses `pathGenerator.getPiecePath()` for outlines. Replace it:
   - Instead of drawing path outlines, draw each piece PNG at low alpha (e.g., alpha=40) to show faint jigsaw outlines over the full painting. This ensures peek mode outlines also match the PNG shapes.
   - OR: Skip piece outlines in peek mode entirely if the grid lines are sufficient. The key requirement is that peek mode must not crash or use the old pathGenerator.
   - Simplest approach: draw piece PNGs with very low alpha using a dedicated paint:
   ```kotlin
   private val peekPiecePaint = Paint(Paint.ANTI_ALIAS_FLAG or Paint.FILTER_BITMAP_FLAG).apply {
       alpha = 40
   }
   ```

6. **Remove PuzzlePiecePathGenerator usage:**
   - Remove the `private val pathGenerator = PuzzlePiecePathGenerator()` field
   - Remove `pathGenerator.invalidateCache()` calls from `setPainting()` and `onSizeChanged()`
   - Remove the import of PuzzlePiecePathGenerator if it becomes unused

7. **Delete or deprecate PuzzlePiecePathGenerator.kt:**
   - Since no other file uses it (confirmed by grep), delete `PuzzlePiecePathGenerator.kt` entirely
   - This eliminates dead code and the confusing dual-shape system

8. **Ensure `setLayerType(LAYER_TYPE_SOFTWARE, null)` is present** in init — it's already there (line 166). This is required for `saveLayer()` compositing to work correctly. NOTE: If hardware acceleration issues arise, this is already handled.

9. **Run `./gradlew ktlintFormat`** to ensure code style compliance.

10. **Run `./gradlew assemblePlayDebug`** to verify compilation.

**What NOT to do:**
- Do NOT attempt to trace PNG outlines into Path objects (fragile, complex, and unnecessary)
- Do NOT change the locked piece rendering (drawLockedPiecePng works correctly)
- Do NOT change getPieceType() logic (the checkerboard alternation is correct from v1.0)
- Do NOT change PIECE_BODY_OFFSETS (the per-piece offsets are correct from v1.0)
- Do NOT remove the pieceBorderPaint field yet — it may be reused later
  </action>
  <verify>
1. `./gradlew assemblePlayDebug` compiles without errors
2. `./gradlew ktlintFormat` produces no changes (code is already formatted)
3. Grep confirms no remaining references to PuzzlePiecePathGenerator in source code:
   `grep -r "PuzzlePiecePathGenerator" AnkiDroid/src/main/java/` returns nothing
4. Grep confirms alphaMaskPaint or DST_IN is used in PaintingPuzzleView:
   `grep -E "alphaMaskPaint|DST_IN" AnkiDroid/src/main/java/com/ichi2/anki/ui/museum/PaintingPuzzleView.kt`
5. PuzzlePiecePathGenerator.kt file no longer exists
  </verify>
  <done>
Unlocked pieces use PNG alpha mask compositing (PorterDuff DST_IN) with the same piece bitmaps used for locked pieces. PuzzlePiecePathGenerator is deleted. Peek mode uses PNG-based outlines. Build compiles successfully.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Visual verification of shape match between locked and unlocked pieces</name>
  <action>
Build and install the app, then visually verify that unlocked puzzle pieces now clip to the exact same jigsaw shape as locked PNG pieces. This is a human verification checkpoint — no code changes.
  </action>
  <what-built>
Replaced PuzzlePiecePathGenerator bezier clip paths with PNG alpha mask clipping for unlocked pieces. Both locked and unlocked pieces now derive their jigsaw shape from the same PNG assets, eliminating the shape mismatch.
  </what-built>
  <how-to-verify>
1. Build and install: `./gradlew installPlayDebug`
2. Open AnkiDroid and navigate to the Museum homescreen
3. Verify locked pieces still display as gray gradient jigsaw (unchanged from v1.0)
4. Unlock a few pieces (or set test data with some unlocked pieces)
5. **Critical check:** Compare the jigsaw outline of an unlocked piece with its locked neighbors:
   - Tabs on the unlocked piece should fit exactly into holes on adjacent locked pieces
   - Holes on the unlocked piece should receive tabs from adjacent locked pieces
   - No visible gap, overlap, or shape mismatch at piece boundaries
6. Check corners: unlock a corner piece and verify the flat edges align with the puzzle border
7. Check borders: unlock a border piece and verify tabs/holes match interior neighbors
8. Check peek mode: activate peek mode and verify it shows the full painting with faint piece outlines (no crash)
9. Check unlock animation: trigger a piece unlock and verify the fade-in animation still works
  </how-to-verify>
  <resume-signal>Type "approved" if shapes match, or describe any visible mismatch</resume-signal>
</task>

</tasks>

<verification>
Phase 2 is complete when:
1. `./gradlew assemblePlayDebug` compiles without errors
2. PuzzlePiecePathGenerator.kt is deleted (no more dual-shape system)
3. Unlocked pieces use PNG alpha mask clipping (same bitmaps as locked pieces)
4. Visual verification confirms no shape mismatch between locked and unlocked pieces
5. Peek mode works without crashing
6. Unlock animation still functions
</verification>

<success_criteria>
User confirms on device:
- Unlocked pieces clip to the exact same jigsaw outline as their locked PNG neighbors
- No visible shape mismatch at any piece boundary (corners, borders, interiors)
- Tab and hole boundaries align perfectly at piece intersections
- All 14 piece variants work correctly when unlocked
</success_criteria>

<output>
After completion, create `.planning/phases/02-shape-system-fix/02-01-SUMMARY.md`
</output>
